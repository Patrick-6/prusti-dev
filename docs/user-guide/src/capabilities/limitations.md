# Current Prusti limitations

In this chapter is a list of Rust features, which are currently not supported by Prusti, or that Prusti struggles with.

## Termination checks (total correctness) missing

Programs checked by Prusti are currently only checked for Partial Correctness, but correct [termination](https://en.wikipedia.org/wiki/Termination_analysis) is not checked. This means that any checked properties are only correct, if there are no infinite loops or infinite recursion in your code.

```rust,noplaypen,ignore 
# use prusti_contracts::*;
# 
#[ensures(false)] // Partial Correctness: This holds, if the function terminates, but termination is not checked
pub fn impossible() {
    impossible()
}

fn test() {
    impossible();
    assert!(10 == 5); // This passes
}
```

In this obvious case, `rustc` will help by warning about the unconditional recursion:
```plain
Warning: [unconditional_recursion] function cannot return without recursing.
```

Related Issues:
- [#1170](https://github.com/viperproject/prusti-dev/issues/1170) |



## Iterators
You can currently not verify any code using [iterators](https://doc.rust-lang.org/book/ch13-02-iterators.html) (and thus for loops):

```rust,noplaypen,ignore
for i in 0..100 {
    /* loop body */
}
```

Workaround for the `range` iterator `0..100`:
```rust,noplaypen,ignore
let mut i = 0;
while i < 100 {
    body_invariant!(true);
    /* loop body */
    i += 1;
}
```


## References in structures unsupported

Prusti does not support any structures (tuples, structs, enums, slices) containing references.

```rust,noplaypen,ignore
fn try_peek(list: &List<i32>) -> Option<&i32>
```

Related Issues:
- Any issue with the [`refs-in-struct` label](https://github.com/viperproject/prusti-dev/labels/refs-in-structs)



## Closures not fully supported

Prusti does currently not fully support [closures](https://doc.rust-lang.org/book/ch13-01-closures.html).

```rust,noplaypen,ignore
// NOT SUPPORTED:
# use prusti_contracts::*;
# 
fn test() {
    let values = [1, 2, 4];
    let test_closure = |arr: &[i32], i: usize| {arr[i]};
    let mid = test_closure(&values, 1);
    prusti_assert!(mid == 2);
}
```

Work on supporting closures is paused at least until the [pull request to annotate parts of the standard library](https://github.com/viperproject/prusti-dev/pull/138) is completed and merged.



## Loops in pure functions unsupported

Pure functions can only contain recursion at the moment, no `loop`, `while` or `for`.

The workaround for this issue is to rewrite any loops in pure functions with recursion.

Related Issues:
- [#576](https://github.com/viperproject/prusti-dev/issues/576)

## `unsafe` code

### TODO
Verficiation of `unsafe` code is currently being worked on. The current work in progress can be used with the config flag [`UNSAFE_CORE_PROOF`](https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#unsafe_core_proof), but it is still incomplete.



## Quantifiers and triggers

### TODO
Quantifiers need to be correctly triggered during verification. These triggers are either user-supplied or automatically generated by Prusti. This is generation is not perfect at the moment, and the user is also not informed about which triggers have been selected. One place this can show up is in nested loops, which are currently hard to verify.



## Non-Copy types in `#[pure]` functions

Parameters and return types of `#[pure]` functions currently need to implement the [`Copy` trait](https://doc.rust-lang.org/std/marker/trait.Copy.html).

- Allowed types:
  - `i8`, `i16`, `i32`, `i64`, `i128`
  - `u8`, `u16`, `u32`, `u64`, `u128`
  - `bool`
  - `f32`, `f64` (but floating point is not fully supported yet)
  - `&T`
  - `struct`, `enum`, slices and stuples that implement `Copy`
- Disallowed types:
  - `&mut T`
  - `struct` and `enum` that do not implement `Copy`

Verification languages like [Dafny](https://dafny.org/) allows pure functions to use recursive types like this List type:

```js
datatype Tree<T> = Leaf(data: T) | Node(left: Tree<T>, right: Tree<T>)

function Mirror<T>(t: Tree<T>): Tree<T> {
    match t
    case Node(Leaf(x), Leaf(y)) =>  Node(Leaf(y), Leaf(x))
    case Node(left, right) => Node(Mirror(right), Mirror(left))
    case Leaf(x) => Leaf(x)
}
```
In Prusti, this does not work:
```rust,noplaypen
# // The next line is only required for doctests, you can ignore/remove it
# extern crate prusti_contracts;
# use prusti_contracts::*;
# 
pub enum Tree<T> {
    Leaf(T),
    Node(Box<Tree<T>>, Box<Tree<T>>),
}

impl<T> Tree<T> {
    #[pure]
    pub fn mirror(self) -> Self {
        match self {
            Tree::Leaf(t) => Tree::Leaf(t),
            Tree::Node(l, r) => Tree::Node(Box::new(r.mirror()), Box::new(l.mirror())),
        }
    }
}
```
This code does not work, because the parameter `self` and the return type are not `Copy`. Also, the `Box::new` function is not pure, since it takes a `Tree<T>`, so we cannot call it from inside a pure function.

### Future plans

In the future, the types usable in `#[pure]` functions is planned to get expanded from just `Copy` types.
General allocation in pure functions should be allowed, as long as the allocations don't leak outside the function.

### TODO: related PRs / issues



## Floating point values

Floating point support is not yet complete, e.g.:
```rust,noplaypen,ignore
# use prusti_contracts::*;
# 
fn test() {
    let x: f64 = 0.1;
    let y = 0.2;
    let z = x + y;
    assert!(z == y + x); // Passes
    prusti_assert!(z == y + x); // Passes
    // prusti_assert!(z == y + x + 10.0); // Correctly fails
    prusti_assert!(f64::NAN == f64::NAN); // Verifies, but shouldn't
    prusti_assert!(z === y + x); // Should verify, but doesn't: [Prusti: verification error] the asserted expression might not hold
}
```

Related Issues
- [Incorrect results of floating-point operations](https://github.com/viperproject/prusti-dev/issues/575)

### TODO



## Mutable function arguments not supported

Functions with mutable references work (`&mut self`), but not mutable non-reference arguments (like `x: mut i32`). A workaround is to make the parameter immutable, then immediately assign it to a mutable local variable with the same name.

```rust,noplaypen
# // The next line is only required for doctests, you can ignore/remove it
# extern crate prusti_contracts;
use prusti_contracts::*;

// This fails:
fn mut_swap(mut x: i64, mut y: i64) -> (i64, i64){
    (x, y) = (y, x);
    (x, y)
}

// Workaround:
fn mut_swap_workaround(x: i64, y: i64) -> (i64, i64){
    let mut x = x;
    let mut y = y;
    (x, y) = (y, x);
    (x, y)
}

// Better workaround in case of `swap` without mutability:
fn swap(x: i64, y: i64) -> (i64, i64) {
    (y, x)
}
```

Related Issues:
- [#1203](https://github.com/viperproject/prusti-dev/issues/1203)



## Strings and string slices

The Rust types `String` and `str` are not yet supported by Prusti.
To verify functions that use strings, you can use trusted functions like this:
```rust,noplaypen
# // The next line is only required for doctests, you can ignore/remove it
# extern crate prusti_contracts;
use prusti_contracts::*;

#[trusted]
fn trusted_println(s: &str) {
    println!("{s}");
}
```

## Verifying unit tests

Unit tests (marked by `#[cfg(test)]` or `#[test]`) are currently not verified by Prusti, but this may be added in the future.

By removing `#[cfg(test)]` and `#[test]` from a test, Prusti will be able to verify it like a normal function.